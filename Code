package main

import (
	"bytes"
	"context"
	"crypto/tls"
	"crypto/x509"
	"encoding/json"
	"fmt"
	"github.com/goburrow/modbus"
	"github.com/hyperledger/fabric-gateway/pkg/client"
	"github.com/hyperledger/fabric-gateway/pkg/hash"
	"github.com/hyperledger/fabric-gateway/pkg/identity"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials"
	"log"
	"net/http"
	"os"
	"strconv"
	"time"
)

func main() {
	//ctx := context.Background()
	//ctxx, _ := context.WithTimeout(ctx, 10000*time.Second)
	net := BlockChainInit2()
	Querytest(net)
	//ListenEvent()

	//SendToThingsBoard2(777)
	//ModbusClient, err := ModbusInit()
	//if err != nil {
	//	log.Fatal("Modbus init failed:", err)
	//}
	//for {
	//	t, _ := ModbusClient.ReadHoldingRegisters(5, 2)
	//	floatVal := math.Float32frombits(binary.BigEndian.Uint32(t))
	//
	//	log.Println("Read HoldingRegisters ", floatVal)
	//	//SendToThingsBoard(floatVal)
	//	time.Sleep(1 * time.Second)
	//}
}

func ControlValve(ip string, port int, addr uint16, value uint16) error {
	// 1ï¸âƒ£ åˆ›å»º TCP å®¢æˆ·ç«¯å¤„ç†å™¨
	handler := modbus.NewTCPClientHandler(fmt.Sprintf("%s:%d", ip, port))
	handler.Timeout = 5 * time.Second
	handler.SlaveId = 1
	defer handler.Close()

	if err := handler.Connect(); err != nil {
		return fmt.Errorf("è¿æ¥ Modbus è®¾å¤‡å¤±è´¥: %w", err)
	}
	client := modbus.NewClient(handler)

	_, err := client.WriteSingleRegister(addr, value)
	if err != nil {
		return fmt.Errorf("å†™å¯„å­˜å™¨å¤±è´¥: %w", err)
	}

	results, err := client.ReadHoldingRegisters(addr, 5)
	if err != nil {
		return fmt.Errorf("è¯»å–å¯„å­˜å™¨å¤±è´¥: %w", err)
	}

	log.Printf(" å†™å…¥å®Œæˆ: å¯„å­˜å™¨[%d]=%d, å½“å‰å¯„å­˜å™¨å€¼=%v\n", addr, value, results)
	return nil
}

func BlockChainInit() *client.Network {
	// ====== 0) åŸºæœ¬å‚æ•°ï¼ˆæŒ‰ä½ çš„ç¯å¢ƒä¿®æ”¹ï¼‰ ======
	mspID := "Org1MSP"

	// Peer çš„ TLS æ ¹è¯ä¹¦ï¼ˆä¸æ˜¯ç”¨æˆ·è¯ä¹¦ï¼‰
	tlsCertPath := "./ca.crt"

	// ç”¨æˆ·èº«ä»½ï¼šè¯ä¹¦ + ç§é’¥ï¼ˆUser1 æˆ– Admin éƒ½è¡Œï¼‰
	userCertPath := "./User1@org1.example.com-cert.pem"
	userKeyPath := "./priv_sk"

	// ç”¨è¯ä¹¦é‡Œçš„ DNS åç§°è¿ï¼Œå¹¶ç¡®ä¿ hosts å¯è§£æåˆ°ä½ çš„ IP
	peerEndpoint := "peer0.org1.example.com:7051"
	serverName := "peer0.org1.example.com" // å¿…é¡»ä¸è¯ä¹¦ SAN åŒ¹é…

	channelName := "mychannel"

	// ====== 1) TLS å‡†å¤‡ï¼ˆæ ¹è¯ä¹¦ + ServerNameï¼‰ ======
	tlsPem, err := os.ReadFile(tlsCertPath)
	if err != nil {
		log.Fatalf("read tls ca: %v", err)
	}
	cp := x509.NewCertPool()
	if !cp.AppendCertsFromPEM(tlsPem) {
		log.Fatal("failed to add tls ca pem to pool")
	}
	tlsCfg := &tls.Config{
		RootCAs:    cp,
		ServerName: serverName, // å…³é”®ï¼šè®©æ¡æ‰‹ä¸»æœºååŒ¹é…è¯ä¹¦é‡Œçš„ DNS SAN
	}
	creds := credentials.NewTLS(tlsCfg)

	// ä¹Ÿå¯ä»¥ç”¨ IP ç›´è¿ï¼špeerEndpoint = "192.168.88.131:7051"
	// ä½†ä»éœ€è®¾ç½® ServerName = è¯ä¹¦é‡Œçš„ DNSï¼ˆå¦‚ peer0.org1.example.comï¼‰

	conn, err := grpc.Dial(peerEndpoint, grpc.WithTransportCredentials(creds))
	if err != nil {
		log.Fatalf("grpc dial: %v", err)
	}
	defer conn.Close()

	// ====== 2) èº«ä»½ï¼ˆç”¨æˆ·è¯ä¹¦ + ç§é’¥ï¼‰ ======
	certPem, err := os.ReadFile(userCertPath)
	if err != nil {
		log.Fatalf("read user cert: %v", err)
	}
	x509Cert, err := identity.CertificateFromPEM(certPem)
	if err != nil {
		log.Fatalf("parse user cert: %v", err)
	}
	id, _ := identity.NewX509Identity(mspID, x509Cert)

	keyPem, err := os.ReadFile(userKeyPath)
	if err != nil {
		log.Fatalf("read user key: %v", err)
	}
	privateKey, err := identity.PrivateKeyFromPEM(keyPem)
	if err != nil {
		log.Fatalf("parse user key: %v", err)
	}
	sign, err := identity.NewPrivateKeySign(privateKey)
	if err != nil {
		log.Fatalf("new signer: %v", err)
	}

	// ====== 3) è¿æ¥ Gateway ======
	gateway, err := client.Connect(
		id,
		client.WithSign(sign),
		client.WithClientConnection(conn),
		client.WithHash(hash.SHA256),
	)
	if err != nil {
		log.Fatalf("connect gateway: %v", err)
	}
	defer gateway.Close()

	network := gateway.GetNetwork(channelName)
	return network
}
func BlockChainInit2() *client.Network {

	mspID := "Org1MSP"
	tlsCertPath := "./ca.crt"
	userCertPath := "./User1@org1.example.com-cert.pem"
	userKeyPath := "./priv_sk"
	peerEndpoint := "peer0.org1.example.com:7051"
	serverName := "peer0.org1.example.com"
	channelName := "mychannel"

	// ====== 1) TLS å‡†å¤‡ï¼ˆæ ¹è¯ä¹¦ + ServerNameï¼‰ ======
	tlsPem, err := os.ReadFile(tlsCertPath)
	if err != nil {
		panic(fmt.Errorf("failed to read TLS certifcate file: %w", err))
	}
	certificate, err := identity.CertificateFromPEM(tlsPem)
	if err != nil {
		panic(err)
	}
	cp := x509.NewCertPool()
	cp.AddCert(certificate)
	transportCredentials := credentials.NewClientTLSFromCert(cp, serverName)
	conn, err := grpc.NewClient(peerEndpoint, grpc.WithTransportCredentials(transportCredentials))
	if err != nil {
		panic(fmt.Errorf("failed to create gRPC connection: %w", err))
	}

	// ä¹Ÿå¯ä»¥ç”¨ IP ç›´è¿ï¼špeerEndpoint = "192.168.88.131:7051"
	// ä½†ä»éœ€è®¾ç½® ServerName = è¯ä¹¦é‡Œçš„ DNSï¼ˆå¦‚ peer0.org1.example.comï¼‰

	defer conn.Close()

	// ====== 2) èº«ä»½ï¼ˆç”¨æˆ·è¯ä¹¦ + ç§é’¥ï¼‰ ======
	certPem, err := os.ReadFile(userCertPath)
	if err != nil {
		log.Fatalf("read user cert: %v", err)
	}
	x509Cert, err := identity.CertificateFromPEM(certPem)
	if err != nil {
		log.Fatalf("parse user cert: %v", err)
	}
	id, _ := identity.NewX509Identity(mspID, x509Cert)

	keyPem, err := os.ReadFile(userKeyPath)
	if err != nil {
		log.Fatalf("read user key: %v", err)
	}
	privateKey, err := identity.PrivateKeyFromPEM(keyPem)
	if err != nil {
		log.Fatalf("parse user key: %v", err)
	}
	sign, err := identity.NewPrivateKeySign(privateKey)
	if err != nil {
		log.Fatalf("new signer: %v", err)
	}

	// ====== 3) è¿æ¥ Gateway ======
	gateway, err := client.Connect(
		id,
		client.WithSign(sign),
		client.WithClientConnection(conn),
		client.WithHash(hash.SHA256),
		/* åˆå§‹åŒ–ä½¿ç”¨ */
		client.WithEvaluateTimeout(5*time.Second),
		client.WithEndorseTimeout(15*time.Second),
		client.WithSubmitTimeout(5*time.Second),
		client.WithCommitStatusTimeout(1*time.Minute),
	)

	if err != nil {
		log.Fatalf("connect gateway: %v", err)
	}
	defer gateway.Close()

	network := gateway.GetNetwork(channelName)
	return network
}
func ListenEvent() {

	ctx := context.Background()
	network := BlockChainInit()

	chaincodeName := "IoTTest2" // ä½ çš„é“¾ç åï¼›å¦‚æœåªæ˜¯æµ‹è¯•ï¼Œä¹Ÿå¯ä»¥ç”¨ "basic"

	events, _ := network.ChaincodeEvents(ctx, chaincodeName /*, client.WithStartBlock(0)*/)
	log.Printf("ğŸ“¡ äº‹ä»¶ç›‘å¬å·²å¯åŠ¨ï¼šchaincode=%s\n", chaincodeName)
	// for select å¹¶è¡Œç­‰å¾…æ•°æ®
	for {
		select {
		case ev, ok := <-events:
			log.Printf(" äº‹ä»¶: name=%s tx=%s block=%d", ev.EventName, ev.TransactionID, ev.BlockNumber)
			if !ok {
				log.Println("âœ… äº‹ä»¶é€šé“å·²å…³é—­ï¼Œé€€å‡ºç›‘å¬")
				return
			} else if ev == nil {
				log.Println(" æ”¶åˆ° nil äº‹ä»¶ï¼Œå¿½ç•¥")
				continue
			} else if ev.EventName == "CommandEvent" {

				var DecodeedJSON map[string]interface{}
				err := json.Unmarshal(ev.Payload, &DecodeedJSON)
				if err != nil {
					log.Printf("payload(raw): %s\n", string(ev.Payload))
					return
				}
				cmd, ok := DecodeedJSON["Command"].(bool)
				if ok {
					if cmd == true {
						go func() {
							if err := ControlValve("192.168.2.1", 1000, 0, 1); err != nil {
								log.Printf(" Modbus æ§åˆ¶å¤±è´¥: %v", err)
							}
						}()
					} else if cmd == false {
						go func() {
							if err := ControlValve("192.168.2.1", 1000, 0, 0); err != nil {
								log.Printf(" Modbus æ§åˆ¶å¤±è´¥: %v", err)
							}
						}()
					}

				} else {
					log.Println("âš ï¸ æ²¡æœ‰æ‰¾åˆ° cmd å­—æ®µæˆ–ä¸æ˜¯å­—ç¬¦ä¸²")
				}

			} else if ev.EventName == "UploadDeviceDataEvent" {
				log.Println("âš ï¸ æ‰¾åˆ° UploadDeviceDataEvent")
			} else {
				continue
			}

		case <-ctx.Done():
			log.Println("ğŸ›‘ ä¸Šä¸‹æ–‡å–æ¶ˆï¼Œé€€å‡ºç›‘å¬")
			return
		default:

		}

	}

}

func ListenPLC() {}

func ModbusInit() (modbus.Client, error) {
	// åˆ›å»º Modbus å®¢æˆ·ç«¯ handler
	ModbusConnection := modbus.NewTCPClientHandler("192.168.2.1:1000")
	ModbusConnection.Timeout = 10 * time.Second
	ModbusConnection.SlaveId = 1
	if err := ModbusConnection.Connect(); err != nil {
		log.Printf("Modbusè¿æ¥å¤±è´¥: %v", err)
		return nil, err
	}
	log.Println("Modbusè¿æ¥æˆåŠŸ")

	ModbusClient := modbus.NewClient(ModbusConnection)
	// è¿”å› handler å’Œ nil é”™è¯¯
	return ModbusClient, nil
}

func SendToThingsBoard(floatVal float32, timestamp int64) {
	data := map[string]interface{}{
		"ts": timestamp,
		"values": map[string]interface{}{
			"temperature": floatVal,
		},
	}
	jsonData, err := json.Marshal(data)
	if err != nil {
		log.Fatal(err)
	}

	req, err := http.NewRequest("POST", "http://192.168.88.129:8080/api/v1/5nUpzAxKz1qXCGSBu4lT/telemetry", bytes.NewBuffer(jsonData))
	if err != nil {
		log.Fatal(err)
	}
	req.Header.Set("Content-Type", "application/json")

	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		log.Fatal(err)
	}
	defer resp.Body.Close()
}

func ExecuteContractFunction(ctx context.Context, network *client.Network) {
	// è·å–æŒ‡å®šé“¾ç çš„åˆçº¦
	contract := network.GetContract("IoTTest2")
	// æ‰§è¡Œé“¾ç æŸ¥è¯¢æ“ä½œ
	result, err := contract.SubmitWithContext(

		ctx, "ControlDevice", client.WithArguments(strconv.FormatBool(true)))

	if err != nil {
		log.Fatalf("äº¤æ˜“æ‰§è¡Œå¤±è´¥: %v", err)
	}

	// è¾“å‡ºäº¤æ˜“çš„å“åº”ç»“æœ
	fmt.Printf("äº¤æ˜“æˆåŠŸï¼Œè¿”å›ç»“æœ: %s\n", string(result)) // å¤„ç† []byte æ•°æ®å¹¶è½¬æ¢ä¸ºå­—ç¬¦ä¸²
}

func Querytest(network *client.Network) {
	// è·å–æŒ‡å®šé“¾ç çš„åˆçº¦
	contract := network.GetContract("Organizationcc")
	// æ‰§è¡Œé“¾ç æŸ¥è¯¢æ“ä½œ
	result, err := contract.EvaluateTransaction("ReadOrganization", "id-0000")

	if err != nil {
		log.Fatalf("äº¤æ˜“æ‰§è¡Œå¤±è´¥: %v", err)
	}
	// è¾“å‡ºäº¤æ˜“çš„å“åº”ç»“æœ
	fmt.Printf("äº¤æ˜“æˆåŠŸï¼Œè¿”å›ç»“æœ: %s\n", string(result)) // å¤„ç† []byte æ•°æ®å¹¶è½¬æ¢ä¸ºå­—ç¬¦ä¸²
}
